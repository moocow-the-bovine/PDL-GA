##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = '0.01';
pp_setversion($VERSION);

##------------------------------------------------------
## pm additions
pp_addpm({At=>'Top'},<<'EOPM');
use strict;

=pod

=head1 NAME

PDL::GA - Genetic algorithm utilities for PDLs.

=head1 SYNOPSIS

 use PDL;
 use PDL::GA;

 ##-------------------------------------------------------------
 ## TODO...

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
pp_export_nothing();

##------------------------------------------------------
## Includes / defines
#pp_addhdr(<<'EOH');
#EOH

##======================================================================
## C Utilities
##======================================================================
pp_addhdr(<<'EOH');
/*-- C header stuff goes here --*/
#include <stdlib.h>
EOH


##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Basic Utilities
pp_addpm(<<'EOPM');
#=pod
#
#=head1 Basic Utilities
#
#=cut
EOPM

##======================================================================
## Convenience Methods

##------------------------------------------------------
## Roulette-wheel selection
pp_add_exported('','roulette');
pp_addpm(<<'EOPM');

=pod

=head2 roulette

=for sig

  Signature: (weightmap(M); %options)
  Options:
    n  => $n
    to => [o]selindices($n)

Stochastic (roulette-wheel) selection of $n objects from
$M objects, governed by the likelihood distribution $weightmap().
Calls PDL::Primitive::vsearch().

=cut

EOPM
pp_addpm(<<'EOPM');
sub roulette {
  my ($wmap,%opts) = @_;
  my ($seli);
  if (defined($opts{to})) {
    $seli = $opts{to};
  } elsif (defined($opts{n})) {
    $seli = zeroes(long,$opts{n}) if (!defined($seli));
    $seli->resize($opts{n})
      if ($seli->ndims != 1 || $seli->dim(0) != $opts{n});
  } else {
    $seli = zeroes(long,1);
  }
  my $selw = PDL->random($seli->nelem);
  $selw *= $wmap->sumover;
  $selw->vsearch($wmap->cumusumover, $seli);
  return $seli;
}
EOPM


##======================================================================
## Stochastic selection (roulette-wheel)

##------------------------------------------------------
## weightselect() : weighted selection
pp_add_exported('','weightselect');
pp_addpm(<<'EOPM');

=pod

=head2 weightselect

=for sig

  Signature: (weightmap(M); selweights(S); [o]selindices(S))

Stochastically select $S objects from a pool $M objects, allowing repetitions.
Likelihood selecting an object $i is given by $weightmap($i).  Target
selection likelihoods are passed as $selweights(), which should have
values in the range [0,sum($weightmap)\(.  Selected targets are
returned as indices in the range [0,$M\( in the PDL $selindices().

See also:
roulette(),
cweightselect(),
PDL::Primitive::vsearch(),
PDL::Ufunc::cumusumover().

=cut

EOPM
pp_addpm(<<'EOPM');
sub weightselect {
  #my ($wmap,$selw,$seli) = splice(@_,0,2);
  return
    #$selw->vsearch($wmap->cumusumover, @_);
    $_[1]->vsearch($_[0]->cumusumover, @_[2..$#_]);
}
EOPM


##------------------------------------------------------
## cweightselect() : weighted selection (cumulative)
pp_add_exported('','cweightselect');
pp_addpm(<<'EOPM');

=pod

=head2 cweightselect

=for sig

  Signature: (weightmap(M); selweights(S); [o]selindices(S))

Stochastically select $S objects from a pool $M objects, allowing repetitions.
Cumulative likelihood selecting an object $i is given by $weightmap($i).  Target
selection likelihoods are passed as $selweights(), which should have
values in the range [0,sum($weightmap)\(.  Selected targets are
returned as indices in the range [0,$M\( in the PDL $selindices().
Really just a wrapper for PDL::vsearch().

See also:
roulette(),
weightselect(),
PDL::Primitive::vsearch(),
PDL::Ufunc::cumusumover().

=cut

EOPM
pp_addpm(<<'EOPM');
sub cweightselect {
  #my ($cwmap,$selw,$seli) = splice(@_,0,2);
  return
    #$selw->vsearch($cwmap, @_);
    $_[1]->vsearch($_[0], @_[2..$#_]);
}
EOPM

##======================================================================
## Mutation

##------------------------------------------------------
## mutate_bool() : logical (boolean) mutation
pp_add_exported('','mutate_bool');
pp_addpm(<<'EOPM');

=pod

=head2 mutate_bool

=for sig

  Signature: (genes(G); float+ rate(G); [o]mutated(G))

Mutate genes with boolean-valued features.

=cut

EOPM
pp_addpm(<<'EOPM');
sub mutate_bool {
  my ($genes,$rate,$mutated) = @_;
  if ($genes->is_inplace) {
    $mutated = $genes;
  } elsif (!defined($mutated)) {
    $mutated = pdl($genes);
  } else {
    $mutated .= $genes;
  }
  my $mutate_i = (PDL->random($mutated->nelem) < $rate)->which;
  if (!$mutate_i->isempty) {
    $mutated->flat->index($mutate_i)->inplace->not();
  }
  return $mutated;
}
EOPM


##------------------------------------------------------
## mutate_range() : mutation of interval-data genes
pp_def
('mutate_range',
 Pars => 'genes(G); float+ rate(G); min(G); max(G); [o]mutated(G)',
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   if (drand48() < $rate()) {
     $mutated() = $min() + drand48()*($max()-$min());
   } else {
     $mutated() = $genes();
   }
 %}
'),
  Doc =>
  ('Mutate genes in the range [$min,$max\(.'),
);

##------------------------------------------------------
## mutate_addrange() : additive mutation of scalar genes
pp_def
('mutate_addrange',
 Pars => 'genes(G); float+ rate(G); min(G); max(G); [o]mutated(G)',
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   if (drand48() < $rate()) {
     $mutated()  = $genes() + $min() + drand48()*($max()-$min());
   } else {
     $mutated()  = $genes();
   }
 %}
'),
  Doc =>
  ('Mutate genes by adding values in the range [$min,$max\(.'),
);


##------------------------------------------------------
## mutate_bits() : bitwise mutation (integer types only!)
pp_def
('mutate_bits',
 Pars => 'genes(G); float+ rate(G); [o]mutated(G)',
 GenericTypes => [qw(B S U L)],
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   $GENERIC(genes) gene  = $genes();
   $GENERIC(rate)  mrate = $rate();
   int i;
   for (i=0; i < 8*sizeof($GENERIC(genes)); i++) {
     int mask = 1<<i;
     if (drand48() < mrate) {
       if (gene & mask) { gene &= ~mask; }
       else             { gene |=  mask; }
     }
   }
   $mutated() = gene;
 %}
'),
  Doc =>
  ('Mutate traditional bit-string genes.'),
);


##======================================================================
## Crossover

##------------------------------------------------------
## xover1() : single-point crossover
pp_def
('xover1',
 Pars => 'mom(G); dad(G); int xpoint(); [o]kid(G)',
 Code =>
('
 int xat = $xpoint();
 loop(G) %{
   if (G < xat) {
     $kid() = $mom();
   } else {
     $kid() = $dad();
   }
 %}
'),
  Doc =>
  ('Single-point crossover.
$kid() is computed by single-point crossover of $mom() (initial subsequence)
and $dad() (final subsequence).  For symmetric crossover (two offspring per crossing),
call this method twice:

  $kid1 = xover1($mom, $dad, $points);
  $kid2 = xover1($dad, $mom, $points);

'),
);


##------------------------------------------------------
## xover2() : dual-point crossover
pp_def
('xover2',
 Pars => 'mom(G); dad(G); int xstart(); int xend(); [o]kid(G)',
 Code =>
('
 int xstartat = $xstart();
 int xendat   = $xend();
 loop(G) %{
   if (G < xstartat || G >= xendat) {
     $kid() = $mom();
   } else {
     $kid() = $dad();
   }
 %}
'),
  Doc =>
  ('Dual-point crossover.
$kid() is computed by dual-point crossover of $mom() (initial and final subsequences)
and $dad() (internal subsequence).  For symmetric crossover (two offspring per crossing),
call this method twice:

  $kid1 = xover2($mom, $dad, $points1, $points2);
  $kid2 = xover2($dad, $mom, $points1, $points2);

'),
);


##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2006, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl).

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
