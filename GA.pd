##-*- Mode: CPerl -*-

##======================================================================
## Header Administrivia
##======================================================================

our $VERSION = '0.01';
pp_setversion($VERSION);

##------------------------------------------------------
## pm additions
pp_addpm({At=>'Top'},<<'EOPM');
use strict;

=pod

=head1 NAME

PDL::GA - Genetic algorithm utilities for PDLs.

=head1 SYNOPSIS

 use PDL;
 use PDL::GA;

 ##-------------------------------------------------------------
 ## TODO...

=cut

EOPM
## /pm additions
##------------------------------------------------------

##------------------------------------------------------
## Exports: None
pp_export_nothing();

##------------------------------------------------------
## Includes / defines
#pp_addhdr(<<'EOH');
#EOH

##======================================================================
## C Utilities
##======================================================================
pp_addhdr(<<'EOH');
/*-- C header stuff goes here --*/
#include <stdlib.h>
EOH


##======================================================================
## PDL::PP Wrappers
##======================================================================

##======================================================================
## Basic Utilities
pp_addpm(<<'EOPM');
#=pod
#
#=head1 Basic Utilities
#
#=cut
EOPM

##======================================================================
## Convenience Methods

##------------------------------------------------------
## Roulette-wheel selection
pp_add_exported('','roulette');
pp_addpm(<<'EOPM');

=pod

=head2 roulette

=for sig

  Signature: (weightmap(M); %options)
  Options:
    n  => $n
    to => [o]selindices($n)

Stochastic (roulette-wheel) selection of $n objects from
$M objects, governed by the likelihood distribution $weightmap().
Calls PDL::Primitive::vsearch().

=cut

EOPM
pp_addpm(<<'EOPM');
sub roulette {
  my ($wmap,%opts) = @_;
  my ($seli);
  if (defined($opts{to})) {
    $seli = $opts{to};
  } elsif (defined($opts{n})) {
    $seli = zeroes(long,$opts{n}) if (!defined($seli));
    $seli->resize($opts{n})
      if ($seli->ndims != 1 || $seli->dim(0) != $opts{n});
  } else {
    $seli = zeroes(long,1);
  }
  my $selw = PDL->random($seli->nelem);
  $selw *= $wmap->sumover;
  $selw->vsearch($wmap->cumusumover, $seli);
  return $seli;
}
EOPM


##======================================================================
## Stochastic selection (roulette-wheel)

##------------------------------------------------------
## weightselect() : weighted selection
pp_add_exported('','weightselect');
pp_addpm(<<'EOPM');

=pod

=head2 weightselect

=for sig

  Signature: (weightmap(M); selweights(S); [o]selindices(S))

Stochastically select $S objects from a pool $M objects, allowing repetitions.
Likelihood selecting an object $i is given by $weightmap($i).  Target
selection likelihoods are passed as $selweights(), which should have
values in the range [0,sum($weightmap)\(.  Selected targets are
returned as indices in the range [0,$M\( in the PDL $selindices().

See also:
roulette(),
cumuweightselect(),
PDL::Primitive::vsearch(),
PDL::Ufunc::cumusumover().

=cut

EOPM
pp_addpm(<<'EOPM');
sub weightselect {
  #my ($wmap,$selw,$seli) = splice(@_,0,2);
  return
    #$selw->vsearch($wmap->cumusumover, @_);
    $_[1]->vsearch($_[0]->cumusumover, @_[2..$#_]);
}
EOPM


##------------------------------------------------------
## cumuweightselect() : weighted selection (cumulative)
pp_add_exported('','cumuweightselect');
pp_addpm(<<'EOPM');

=pod

=head2 cumuweightselect

=for sig

  Signature: (weightmap(M); selweights(S); [o]selindices(S))

Stochastically select $S objects from a pool $M objects, allowing repetitions.
Cumulative likelihood selecting an object $i is given by $weightmap($i).  Target
selection likelihoods are passed as $selweights(), which should have
values in the range [0,sum($weightmap)\(.  Selected targets are
returned as indices in the range [0,$M\( in the PDL $selindices().
Really just a wrapper for PDL::vsearch().

See also:
roulette(),
weightselect(),
PDL::Primitive::vsearch(),
PDL::Ufunc::cumusumover().

=cut

EOPM
pp_addpm(<<'EOPM');
sub cumuweightselect {
  #my ($cwmap,$selw,$seli) = splice(@_,0,2);
  return
    #$selw->vsearch($cwmap, @_);
    $_[1]->vsearch($_[0], @_[2..$#_]);
}
EOPM

##======================================================================
## bits <-> integer type conversions

##------------------------------------------------------
## int->bits: tobits (safe)
pp_add_exported('','tobits');
pp_addpm(<<'EOPM');

=pod

=head2 tobits

=for sig

  Signature: (ints(); [o]bits(B))

Extract individual bits from integer type pdls.
Output pdl will be created with appropriate dimensions if unspecified.

=cut

EOPM
pp_addpm(<<'EOPM');
sub tobits {
  my ($ints,$bits) = @_;
  $bits = zeroes($ints->type,8*PDL::howbig($ints->type),$ints->dims) if (!defined($bits));
  _tobits($ints,$bits);
  return $bits;
}
EOPM

##------------------------------------------------------
## int->bits: _tobits (requires output pdl)
pp_add_exported('','_tobits');
pp_def
('_tobits',
 Pars => 'a(); [o]bits(B)',
 GenericTypes => [qw(B S U L)],
 Code=>
('
  int i;
  int nbits = 8*sizeof($GENERIC(a));
  if (nbits > $SIZE(B)) nbits = $SIZE(B);
  threadloop %{
    for (i=0; i < nbits; i++) {
      $bits(B=>i) = $a() & (1<<i);
    }
  %}
'),
  Doc=>
('(Low-level method)

Extract individual bits from integer type pdls.
Output pdl $bits() must be specified!
'),
);

##------------------------------------------------------
## bits->int: frombits
pp_add_exported('','frombits');
pp_def
('frombits',
 Pars => 'bits(B); [o]a()',
 GenericTypes => [qw(B S U L)],
 Code=>
('
 int i;
 int nbits = 8*sizeof($GENERIC(a));
 $GENERIC(a) val;
 if (nbits > $SIZE(B)) nbits = $SIZE(B);
 threadloop %{
   val = 0;
   for (i=0; i < nbits; i++) {
     if ($bits(B=>i)) { val |= (1<<i); }
   }
   $a() = val;
 %}
'),
  Doc=>
('Compress expanded bit-pdls to integer types.
'),
);



##======================================================================
## Mutation

##------------------------------------------------------
## mutate_bool() : logical (boolean) mutation
pp_add_exported('','mutate_bool');
pp_def
('mutate_bool',
 Pars => 'genes(G); float+ rate(G); [o]mutated(G)',
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   if (drand48() < $rate()) {
     $mutated() = !$genes();
   } else {
     $mutated() = $genes();
   }
 %}
'),
  Doc =>
  ('Mutate binary-valued (boolean) genes.'),
);


##------------------------------------------------------
## mutate_range() : mutation of interval-data genes
pp_def
('mutate_range',
 Pars => 'genes(G); float+ rate(G); min(G); max(G); [o]mutated(G)',
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   if (drand48() < $rate()) {
     $mutated() = $min() + drand48()*($max()-$min());
   } else {
     $mutated() = $genes();
   }
 %}
'),
  Doc =>
  ('Mutate genes in the range [$min,$max\(.'),
);

##------------------------------------------------------
## mutate_addrange() : additive mutation of scalar genes
pp_def
('mutate_addrange',
 Pars => 'genes(G); float+ rate(G); min(G); max(G); [o]mutated(G)',
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   if (drand48() < $rate()) {
     $mutated()  = $genes() + $min() + drand48()*($max()-$min());
   } else {
     $mutated()  = $genes();
   }
 %}
'),
  Doc =>
  ('Mutate genes by adding values in the range [$min,$max\(.'),
);



##------------------------------------------------------
## mutate_bits
pp_add_exported('','mutate_bits');
pp_addpm(<<'EOPM');

=pod

=head2 mutate_bits

=for sig

  Signature: (genes(G); rate(); [o]mutated(G))

Mutate traditional bit-string genes.
Calls mutate_bool(), tobits(), frombits().

=cut

EOPM
pp_addpm(<<'EOPM');
sub mutate_bits {
  #my ($pop,$rate,$dst) = @_;
  #return $pop->tobits->inplace->mutate_bool($rate)->frombits(defined($dst) ? $dst : qw());
  return $_[0]->tobits->inplace->mutate_bool($_[1])->frombits(@_[2..$#_]);
}
EOPM

##------------------------------------------------------
## _mutate_bits() : bitwise mutation (integer types only!)
pp_def
('_mutate_bits',
 Pars => 'genes(G); float+ rate(G); [o]mutated(G)',
 GenericTypes => [qw(B S U L)],
 Inplace=>['genes'],
 Code =>
('
 loop(G) %{
   $GENERIC(genes) gene  = $genes();
   $GENERIC(rate)  mrate = $rate();
   int i;
   for (i=0; i < 8*sizeof($GENERIC(genes)); i++) {
     int mask = 1<<i;
     if (drand48() < mrate) {
       if (gene & mask) { gene &= ~mask; }
       else             { gene |=  mask; }
     }
   }
   $mutated() = gene;
 %}
'),
  Doc =>
  ('(Low-level method)

Mutate traditional bit-string genes.
This should be equivalent to mutate_bits(), but appears to involve
less overhead (faster for many calls).
'),
);



##======================================================================
## Crossover: low-level

##------------------------------------------------------
## _xover1() : single-point crossover
pp_def
('_xover1',
 Pars => 'mom(G); dad(G); int xpoint(); [o]kid(G)',
 Inplace => ['mom'],
 Code =>
('
 int xat = $xpoint();
 loop(G) %{
   if (G < xat) {
     $kid() = $mom();
   } else {
     $kid() = $dad();
   }
 %}
'),
  Doc =>
  ('(Low-level method)

Single-point crossover.
$kid() is computed by single-point crossover of $mom() (initial subsequence)
and $dad() (final subsequence).  For symmetric crossover (two offspring per crossing),
call this method twice:

  $kid1 = _xover1($mom, $dad, $points);
  $kid2 = _xover1($dad, $mom, $points);

'),
);



##------------------------------------------------------
## _xover2() : dual-point crossover
pp_def
('_xover2',
 Pars => 'mom(G); dad(G); int xstart(); int xend(); [o]kid(G)',
 Inplace => ['mom'],
 Code =>
('
 int xstartat = $xstart();
 int xendat   = $xend();
 loop(G) %{
   if (G < xstartat || G >= xendat) {
     $kid() = $mom();
   } else {
     $kid() = $dad();
   }
 %}
'),
  Doc =>
  ('(Low-level method)

Dual-point crossover.
$kid() is computed by dual-point crossover of $mom() (initial and final subsequences)
and $dad() (internal subsequence).  For symmetric crossover (two offspring per crossing),
call this method twice:

  $kid1 = _xover2($mom, $dad, $points1, $points2);
  $kid2 = _xover2($dad, $mom, $points1, $points2);

'),
);

##======================================================================
## Crossover: high-level

##------------------------------------------------------
## xover1
pp_add_exported('','xover1');
pp_addpm(<<'EOPM');

=pod

=head2 xover1

=for sig

  Signature: (mom(G); dad(G); float+ rate(); [o]kid(G))

Random single-point crossover.
Calls _xover1().

=cut

EOPM
pp_addpm(<<'EOPM');
sub xover1 {
  my ($mom, $dad, $rate, $kid) = @_;
  my $xwhich = (PDL->random($mom->dim(1)) < $rate)->which;
  if ($xwhich->isempty) {
    return ($mom->is_inplace
	    ? $mom
	    : (defined($kid)
	       ? ($kid .= $mom)
	       : ($kid  = pdl($mom))));
  }
  my $xpoint = PDL->zeroes(long,$mom->dim(1)) + $mom->dim(0);
  $xpoint->index($xwhich) .= PDL->random($xwhich->nelem)*($mom->dim(0)-1)+1;
  return _xover1($mom,$dad, $xpoint, (defined($kid) ? $kid : qw()));
}
EOPM


##------------------------------------------------------
## xover2
pp_add_exported('','xover2');
pp_addpm(<<'EOPM');

=pod

=head2 xover2

=for sig

  Signature: (mom(G); dad(G); float+ rate(); [o]kid(G))

Random dial-point crossover.
Calls _xover2().

=cut

EOPM
pp_addpm(<<'EOPM');
sub xover2 {
  my ($mom, $dad, $rate, $kid) = @_;
  my $xwhich = (PDL->random($mom->dim(1)) < $rate)->which;
  if ($xwhich->isempty) {
    return ($mom->is_inplace
	    ? $mom
	    : (defined($kid)
	       ? ($kid .= $mom)
	       : ($kid  = pdl($mom))));
  }
  my $xpoint1 = PDL->zeroes(long,$mom->dim(1)) + $mom->dim(0);
  $xpoint1->index($xwhich) .= PDL->random($xwhich->nelem)*($mom->dim(0)-1)+1;
  my $xpoint2 = pdl($xpoint1);
  $xpoint2->index($xwhich) += 1+PDL->random($xwhich->nelem)*($mom->dim(0)-$xpoint1->index($xwhich));
  return _xover2($mom,$dad, $xpoint1, $xpoint2, (defined($kid) ? $kid : qw()));
}
EOPM



##======================================================================
## Footer Administrivia
##======================================================================

##------------------------------------------------------
## pm additions
pp_addpm(<<'EOPM');

##---------------------------------------------------------------------
=pod

=head1 ACKNOWLEDGEMENTS

Perl by Larry Wall.

PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

=cut

##----------------------------------------------------------------------
=pod

=head1 KNOWN BUGS

Probably many.

=cut


##---------------------------------------------------------------------
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@ling.uni-potsdam.deE<gt>

=head2 Copyright Policy

Copyright (C) 2006, Bryan Jurish. All rights reserved.

This package is free software, and entirely without warranty.
You may redistribute it and/or modify it under the same terms
as Perl itself.

=head1 SEE ALSO

perl(1), PDL(3perl).

=cut

EOPM


# Always make sure that you finish your PP declarations with
# pp_done
pp_done();
##----------------------------------------------------------------------
